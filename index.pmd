% KNN Project
% Jon Craton
% November 9th, 2018

# Initialization

```python
from sklearn.datasets.samples_generator import make_blobs
import numpy as np
import matplotlib.pyplot as plt

import seaborn as sns
sns.set(style="darkgrid")

np.random.seed(6)
import math
from collections import Counter
```

# Data Generation

I've created a function out of the example code to generate multiple scatter plots easily:

```python
def gen_data(n, cluster_std, plot=True):
  n_training = int(.9*n)

  (X,y) =  make_blobs(n_samples=n,n_features=2,centers=2,cluster_std=cluster_std,random_state=50)

  if plot:
    plt.scatter(X[0: n_training][:,0],X[0:n_training][:,1],marker='o',c=y[0:n_training])
    plt.scatter(np.array(X[n_training:])[:,0],np.array(X[n_training:])[:,1],marker='o')
    plt.title("n=%d, std=%.01f" % (n, cluster_std))
    plt.show()  

  return (X[0:n_training],
          y[0:n_training],
          X[n_training:],
          y[n_training:]
         )
```

Let's use this to create the requested plots:

```python
for std in [.5,1,1.5]:
  for n in [50,100,150]:
    gen_data(n, std)
```

```python
(X_train, y_train, X_validation, y_validation) = gen_data(100, 1.95)
```

## Analysis

```python
def get_knn(X,point,k,distance='euclidean'):
  """ 
  Returns the indices of `k` nearest neighbors to `point` in `X`

  >>> get_knn(np.array([(1,1)]),(1,1),1)
  array([0])
  >>> get_knn(np.array([(1,2),(1,1)]),(1,1),1)
  array([1])
  >>> get_knn(np.array([(1,4),(1,1),(1,3),(1,1.5)]),(1,1),2)
  array([1, 3])
  """
  if distance == 'euclidean':
    nn = np.sqrt(np.sum((X - point)**2, axis=1))
  return np.argsort(nn)[0:k]

def predict(prediction_points,k):
  points_labels=[]
  
  for point in prediction_points:
    results=[]
    for index in get_knn(X_train,point,k):
      results.append(y_train[index])
    
    label=Counter(results).most_common(1)
    points_labels.append([point,label[0][0]])
      
  return points_labels

def get_accuracy(predictions):
    error=np.sum((predictions-y_validation)**2)
    accuracy=100-(error/len(y_validation))*100
    return accuracy

acc=[]
for k in range(1,10):
    results=predict(X_validation,k)
    predictions=[]
    for result in results:
        predictions.append(result[1])
    acc.append([get_accuracy(predictions),k])

plotx=[]
ploty=[]
for a in acc:
    plotx.append(a[1])
    ploty.append(a[0])
    
plt.plot(plotx,ploty)
plt.xlabel("k values")
plt.ylabel("accuracy")
plt.show()
```
